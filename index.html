<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Water Quality Dashboard</title>
    <link rel="stylesheet" href="index.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module" src="config.js"></script>
  </head>
  <body>
    <!-- Navbar -->
    <nav class="nav">
      <div class="nav-logo">
        <p>PureFlow</p>
      </div>
      <div class="nav-menu" id="navMenu">
        <ul>
          <li><a href="index.html" class="link active">Home</a></li>
          <li>
            <a href="reportGeneration.html" id="reportLink" class="link"
              >Reports</a>
          </li>
          <li>
            <a href="adminProfile.html" id="adminProfileLink" class="hidden"
              >Admin Profile</a>
          </li>
          <li>
            <a href="staffManagement.html" id="staffLink" class="hidden"
              >Staff Page</a>
          </li>
          <li><a href="about.html" id="aboutLink" class="link">About</a></li>
        </ul>
      </div>
      <div class="nav-button">
        <button class="btn white-btn" id="signInBtn">
          <a href="login.html">Sign In</a>
        </button>
        <button class="btn white-btn hidden" id="signOutBtn">Sign Out</button>
      </div>
      <div class="nav-menu-btn">
        <i class="bx bx-menu" onclick="myMenuFunction()"></i>
      </div>
    </nav>

    <!-- Main header and time range selector container -->
    <div class="header-container">
      <h2>Welcome to your dashboard</h2>
      <div class="time-range-selector">
        <label for="timeRange">Select Time Range: </label>
        <select id="timeRange">
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
    </div>

    <!-- Main container that holds all the charts and data -->
    <div class="container">
      <!-- Main chart container -->
      <div class="main-chart-container">
        <canvas id="myChart" width="400" height="200"></canvas>
      </div>

      <!-- Individual parameter charts and recent values -->
      <div class="individual-charts-container">
        <!-- Temperature -->
        <div class="chart-container">
          <h3>Temperature</h3>
          <canvas id="temperatureChart" width="200" height="100"></canvas>
          <div id="temperatureValue" class="parameter-value">
            <p id="temperatureAvg"></p>
          </div>
        </div>
        <!-- Turbidity -->
        <div class="chart-container">
          <h3>Turbidity</h3>
          <canvas id="turbidityChart" width="200" height="100"></canvas>
          <div id="turbidityValue" class="parameter-value">
            <p id="turbidityAvg"></p>
          </div>
        </div>
        <!-- Water Depth -->
        <div class="chart-container">
          <h3>Water Depth</h3>
          <canvas id="waterDepthChart" width="200" height="100"></canvas>
          <div id="waterDepthValue" class="parameter-value">
            <p id="waterDepthAvg"></p>
          </div>
        </div>
      </div>
    </div>
    <!-- End of container -->

    <script type="module">
      import {
        getFirestore,
        collection,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/9.1.3/firebase-firestore.js";
      import { db, auth } from "./config.js";
      import {
        onAuthStateChanged,
        signOut,
      } from "https://www.gstatic.com/firebasejs/9.1.3/firebase-auth.js";

      const timeRangeSelector = document.getElementById("timeRange");
      const signInBtn = document.getElementById("signInBtn");
      const signOutBtn = document.getElementById("signOutBtn");
      const adminProfileLink = document.getElementById("adminProfileLink");
      const reportLink = document.getElementById("reportLink");
      const staffLink = document.getElementById("staffLink");
      const generateReportBtn = document.getElementById("generateReportBtn");

      function restrictAccess() {
        // Make all links visible but disable them (non-clickable)
        if (adminProfileLink) {
          adminProfileLink.style.pointerEvents = "none"; // Disable interaction
          adminProfileLink.style.opacity = "0.5"; // Visually indicate disabled state
        }
        if (staffLink) {
          staffLink.style.pointerEvents = "none";
          staffLink.style.opacity = "0.5";
        }
        if (reportLink) {
          reportLink.style.pointerEvents = "none";
          reportLink.style.opacity = "0.5";
        }
        if (timeRangeSelector) timeRangeSelector.disabled = true;

        console.log("Access restricted.");
      }

      function grantAccess() {
        // Enable interaction for links
        if (adminProfileLink) {
          adminProfileLink.style.pointerEvents = "auto"; // Enable interaction
          adminProfileLink.style.opacity = "1"; // Reset opacity
        }
        if (staffLink) {
          staffLink.style.pointerEvents = "auto";
          staffLink.style.opacity = "1";
        }
        if (reportLink) {
          reportLink.style.pointerEvents = "auto";
          reportLink.style.opacity = "1";
        }
        if (timeRangeSelector) timeRangeSelector.disabled = false;

        console.log("Access granted.");
      }

      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.log("User is logged in:", user);

          // Hide Sign In Button and show Sign Out Button
          if (signInBtn) signInBtn.style.display = "none";
          if (signOutBtn) signOutBtn.style.display = "inline-block";

          grantAccess();
        } else {
          console.log("No user logged in.");

          // Show Sign In Button and hide Sign Out Button
          if (signInBtn) signInBtn.style.display = "inline-block";
          if (signOutBtn) signOutBtn.style.display = "none";

          restrictAccess();
        }
      });

      signOutBtn.addEventListener("click", async () => {
        try {
          await signOut(auth);
          console.log("Sign-out successful.");
        } catch (error) {
          console.error("Sign-out failed:", error);
        }
      });

      restrictAccess(); // Ensure initial state

      // Water parameters chart functionality
      const waterParametersCollection = collection(db, "water_parameters");
      const mainChartContext = document
        .getElementById("myChart")
        .getContext("2d");

      let allTemperatureData = [];
      let allTurbidityData = [];
      let allWaterDepthData = [];
      let allTimestamps = [];
      let filteredTemperatureData = [];
      let filteredTurbidityData = [];
      let filteredWaterDepthData = [];
      let filteredTimestamps = [];

      let mainChartInstance = null;

      async function fetchData() {
        try {
          const querySnapshot = await getDocs(waterParametersCollection);
          console.log("Data fetched from Firestore:", querySnapshot);

          if (querySnapshot.empty) {
            console.log(
              'No documents found in the "water_parameters" collection.'
            );
          } else {
            querySnapshot.forEach((doc) => {
              const data = doc.data();
              if (
                data.temperature !== undefined &&
                data.turbidity !== undefined &&
                data.waterDepth !== undefined &&
                data.timestamp
              ) {
                const timestamp = data.timestamp;
                if (timestamp && timestamp.seconds) {
                  const date = new Date(timestamp.seconds * 1000);
                  allTimestamps.push(date);
                  allTemperatureData.push(data.temperature);
                  allTurbidityData.push(data.turbidity);
                  allWaterDepthData.push(data.waterDepth);
                }
              }
            });

            console.log("Fetched all data:", {
              allTemperatureData,
              allTurbidityData,
              allWaterDepthData,
              allTimestamps,
            });

            filterDataByTimeRange("daily");
            createMainChart();
            createTemperatureChart(); // Add chart for temperature
            createTurbidityChart(); // Add chart for turbidity
            createWaterDepthChart(); // Add chart for water depth
          }
        } catch (error) {
          console.error("Error fetching data from Firestore:", error);
        }
      }
      function filterDataByTimeRange(timeRange) {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth();
        const currentYear = currentDate.getFullYear();

        filteredTemperatureData = [];
        filteredTurbidityData = [];
        filteredWaterDepthData = [];
        filteredTimestamps = [];

        console.log(`Filtering data for time range: ${timeRange}`);

        switch (timeRange) {
          case "daily":
            allTimestamps.forEach((timestamp, index) => {
              if (timestamp.toDateString() === currentDate.toDateString()) {
                filteredTimestamps.push(timestamp.toLocaleTimeString());
                filteredTemperatureData.push(allTemperatureData[index]);
                filteredTurbidityData.push(allTurbidityData[index]);
                filteredWaterDepthData.push(allWaterDepthData[index]);
              }
            });
            console.log("Filtered daily data:", filteredTemperatureData);
            break;
          case "weekly":
            const weekStart = new Date(
              currentDate.setDate(currentDate.getDate() - currentDate.getDay())
            );
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);

            let weeklyTempSum = 0;
            let weeklyTurbiditySum = 0;
            let weeklyWaterDepthSum = 0;
            let daysInWeek = 0;

            allTimestamps.forEach((timestamp, index) => {
              if (timestamp >= weekStart && timestamp <= weekEnd) {
                weeklyTempSum += allTemperatureData[index];
                weeklyTurbiditySum += allTurbidityData[index];
                weeklyWaterDepthSum += allWaterDepthData[index];
                daysInWeek++;
              }
            });

            if (daysInWeek > 0) {
              filteredTimestamps.push("Week " + (currentDate.getWeek() || 1));
              filteredTemperatureData.push(weeklyTempSum / daysInWeek);
              filteredTurbidityData.push(weeklyTurbiditySum / daysInWeek);
              filteredWaterDepthData.push(weeklyWaterDepthSum / daysInWeek);
            }
            console.log("Filtered weekly data:", filteredTemperatureData);
            break;
          case "monthly":
            let monthlyTempSum = [];
            let monthlyTurbiditySum = [];
            let monthlyWaterDepthSum = [];
            let dayCounts = [];

            allTimestamps.forEach((timestamp, index) => {
              const day = timestamp.getDate();
              if (
                timestamp.getMonth() === currentMonth &&
                timestamp.getFullYear() === currentYear
              ) {
                if (!monthlyTempSum[day]) {
                  monthlyTempSum[day] = 0;
                  monthlyTurbiditySum[day] = 0;
                  monthlyWaterDepthSum[day] = 0;
                  dayCounts[day] = 0;
                }
                monthlyTempSum[day] += allTemperatureData[index];
                monthlyTurbiditySum[day] += allTurbidityData[index];
                monthlyWaterDepthSum[day] += allWaterDepthData[index];
                dayCounts[day]++;
              }
            });

            for (let day = 1; day <= 31; day++) {
              if (dayCounts[day]) {
                filteredTimestamps.push(`Day ${day}`);
                filteredTemperatureData.push(
                  monthlyTempSum[day] / dayCounts[day]
                );
                filteredTurbidityData.push(
                  monthlyTurbiditySum[day] / dayCounts[day]
                );
                filteredWaterDepthData.push(
                  monthlyWaterDepthSum[day] / dayCounts[day]
                );
              }
            }
            console.log("Filtered monthly data:", filteredTemperatureData);
            break;
        }

        createMainChart();
        createTemperatureChart();
        createTurbidityChart();
        createWaterDepthChart();
        displayAverages();
      }

      function updateAverageDisplay() {
        const temperatureAvg =
          filteredTemperatureData.reduce((a, b) => a + b, 0) /
            filteredTemperatureData.length || 0;
        const turbidityAvg =
          filteredTurbidityData.reduce((a, b) => a + b, 0) /
            filteredTurbidityData.length || 0;
        const waterDepthAvg =
          filteredWaterDepthData.reduce((a, b) => a + b, 0) /
            filteredWaterDepthData.length || 0;

        console.log(`Average Temperature: ${temperatureAvg.toFixed(2)} °C`);
        console.log(`Average Turbidity: ${turbidityAvg.toFixed(2)} NTU`);
        console.log(`Average Water Depth: ${waterDepthAvg.toFixed(2)} meters`);

        document.getElementById(
          "temperatureAvg"
        ).textContent = `Average Temperature: ${temperatureAvg.toFixed(2)} °C`;
        document.getElementById(
          "turbidityAvg"
        ).textContent = `Average Turbidity: ${turbidityAvg.toFixed(2)} NTU`;
        document.getElementById(
          "waterDepthAvg"
        ).textContent = `Average Water Depth: ${waterDepthAvg.toFixed(
          2
        )} meters`;
      }

      function createMainChart() {
        if (mainChartInstance) mainChartInstance.destroy();
        mainChartInstance = new Chart(mainChartContext, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Temperature (°C)",
                data: filteredTemperatureData,
                borderColor: "#FF5733",
                backgroundColor: "rgba(255, 87, 51, 0.2)",
                fill: true,
              },
              {
                label: "Turbidity (NTU)",
                data: filteredTurbidityData,
                borderColor: "#33FF57",
                backgroundColor: "rgba(51, 255, 87, 0.2)",
                fill: true,
              },
              {
                label: "Water Depth (m)",
                data: filteredWaterDepthData,
                borderColor: "#3357FF",
                backgroundColor: "rgba(51, 87, 255, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });
      }

      let temperatureChart, turbidityChart, waterDepthChart; // Declare charts globally

      function createTemperatureChart() {
        const ctx = document
          .getElementById("temperatureChart")
          .getContext("2d");

        // Destroy previous chart if it exists
        if (temperatureChart) {
          temperatureChart.destroy();
        }

        // Create new chart
        temperatureChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Temperature (°C)",
                data: filteredTemperatureData,
                borderColor: "#FF5733",
                backgroundColor: "rgba(255, 87, 51, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for temperature
        updateAverageDisplay();
      }

      function createTurbidityChart() {
        const ctx = document.getElementById("turbidityChart").getContext("2d");

        // Destroy previous chart if it exists
        if (turbidityChart) {
          turbidityChart.destroy();
        }

        // Create new chart
        turbidityChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Turbidity (NTU)",
                data: filteredTurbidityData,
                borderColor: "#33FF57",
                backgroundColor: "rgba(51, 255, 87, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for turbidity
        updateAverageDisplay();
      }

      function createWaterDepthChart() {
        const ctx = document.getElementById("waterDepthChart").getContext("2d");

        // Destroy previous chart if it exists
        if (waterDepthChart) {
          waterDepthChart.destroy();
        }

        // Create new chart
        waterDepthChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Water Depth (m)",
                data: filteredWaterDepthData,
                borderColor: "#3357FF",
                backgroundColor: "rgba(51, 87, 255, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for water depth
        updateAverageDisplay();
      }

      function displayAverages() {
        const avgTemp = calculateAverage(filteredTemperatureData);
        const avgTurbidity = calculateAverage(filteredTurbidityData);
        const avgWaterDepth = calculateAverage(filteredWaterDepthData);

        document.getElementById(
          "temperatureAvg"
        ).textContent = `Avg Temperature: ${avgTemp.toFixed(2)} °C`;
        document.getElementById(
          "turbidityAvg"
        ).textContent = `Avg Turbidity: ${avgTurbidity.toFixed(2)} NTU`;
        document.getElementById(
          "waterDepthAvg"
        ).textContent = `Avg Water Depth: ${avgWaterDepth.toFixed(2)} m`;
      }

      function calculateAverage(data) {
        const sum = data.reduce((a, b) => a + b, 0);
        return data.length ? sum / data.length : 0;
      }

      document
        .getElementById("timeRange")
        .addEventListener("change", function (event) {
          console.log("Time range changed:", event.target.value);
          filterDataByTimeRange(event.target.value);
        });

      fetchData();
    </script>
  </body>
</html>

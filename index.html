<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Water Quality Dashboard</title>
    <link rel="stylesheet" href="index.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module" src="config.js"></script>
  </head>
  <body>
    <!-- Navbar -->
    <nav class="nav">
      <div class="nav-logo">
        <p>PureFlow</p>
      </div>
      <div class="nav-menu" id="navMenu">
        <ul>
          <li><a href="index.html" class="link active">Home</a></li>
          <li><a href="#" class="link">Staff</a></li>
          <li><a href="#" class="link">About</a></li>
        </ul>
      </div>
      <div class="nav-button">
        <a href="reportGeneration.html">
          <button class="btn white-btn" id="generateReportBtn">
            Generate Report
          </button>
        </a>
      </div>
      <div class="nav-menu-btn">
        <i class="bx bx-menu" onclick="myMenuFunction()"></i>
      </div>
    </nav>

    <!-- Main header and time range selector container -->
    <div class="header-container">
      <h2>Welcome to your dashboard</h2>
      <div class="time-range-selector">
        <label for="timeRange">Select Time Range: </label>
        <select id="timeRange">
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
    </div>

    <!-- Main container that holds all the charts and data -->
    <div class="container">
      <!-- Main chart container -->
      <div class="main-chart-container">
        <canvas id="myChart" width="400" height="200"></canvas>
      </div>

      <!-- Individual parameter charts and recent values -->
      <div class="individual-charts-container">
        <div class="chart-container">
          <h3>Temperature</h3>
          <canvas id="temperatureChart" width="200" height="100"></canvas>
          <div id="temperatureValue" class="parameter-value">
            <p id="temperatureAvg"></p>
          </div>
        </div>

        <div class="chart-container">
          <h3>Turbidity</h3>
          <canvas id="turbidityChart" width="200" height="100"></canvas>
          <div id="turbidityValue" class="parameter-value">
            <p id="turbidityAvg"></p>
          </div>
        </div>

        <div class="chart-container">
          <h3>Water Depth</h3>
          <canvas id="waterDepthChart" width="200" height="100"></canvas>
          <div id="waterDepthValue" class="parameter-value">
            <p id="waterDepthAvg"></p>
          </div>
        </div>
      </div>
    </div>
    <!-- End of container -->

    <script type="module">
      import {
        getFirestore,
        collection,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/9.1.3/firebase-firestore.js";
      import { db } from "./config.js";

      const waterParametersCollection = collection(db, "water_parameters");
      const mainChartContext = document
        .getElementById("myChart")
        .getContext("2d");

      let allTemperatureData = [];
      let allTurbidityData = [];
      let allWaterDepthData = [];
      let allTimestamps = [];
      let filteredTemperatureData = [];
      let filteredTurbidityData = [];
      let filteredWaterDepthData = [];
      let filteredTimestamps = [];

      let mainChartInstance = null;
      let temperatureChart = null;
      let turbidityChart = null;
      let waterDepthChart = null;

      async function fetchData() {
        try {
          const querySnapshot = await getDocs(waterParametersCollection);

          if (querySnapshot.empty) {
            console.log(
              'No documents found in the "water_parameters" collection.'
            );
          } else {
            querySnapshot.forEach((doc) => {
              const data = doc.data();
              if (
                data.temperature !== undefined &&
                data.turbidity !== undefined &&
                data.waterDepth !== undefined &&
                data.timestamp
              ) {
                const timestamp = data.timestamp;
                if (timestamp && timestamp.seconds) {
                  const date = new Date(timestamp.seconds * 1000);
                  allTimestamps.push(date);
                  allTemperatureData.push(data.temperature);
                  allTurbidityData.push(data.turbidity);
                  allWaterDepthData.push(data.waterDepth);
                }
              }
            });

            filterDataByTimeRange("daily");
            createMainChart();
            createTemperatureChart();
            createTurbidityChart();
            createWaterDepthChart();
          }
        } catch (error) {
          console.error("Error fetching data from Firestore:", error);
        }
      }

      function filterDataByTimeRange(timeRange) {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth();
        const currentYear = currentDate.getFullYear();

        filteredTemperatureData = [];
        filteredTurbidityData = [];
        filteredWaterDepthData = [];
        filteredTimestamps = [];

        if (timeRange === "daily") {
          // Filter for the current day
          allTimestamps.forEach((timestamp, index) => {
            if (timestamp.toDateString() === currentDate.toDateString()) {
              filteredTimestamps.push(timestamp.toLocaleTimeString());
              filteredTemperatureData.push(allTemperatureData[index]);
              filteredTurbidityData.push(allTurbidityData[index]);
              filteredWaterDepthData.push(allWaterDepthData[index]);
            }
          });
        } else if (timeRange === "weekly") {
          // Calculate weekly averages
          const weekStart = new Date();
          weekStart.setDate(currentDate.getDate() - currentDate.getDay()); // Start of the week (Monday)
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekStart.getDate() + 6); // End of the week (Sunday)

          let weeklyTempSum = 0;
          let weeklyTurbiditySum = 0;
          let weeklyWaterDepthSum = 0;
          let daysInWeek = 0;

          allTimestamps.forEach((timestamp, index) => {
            if (timestamp >= weekStart && timestamp <= weekEnd) {
              weeklyTempSum += allTemperatureData[index];
              weeklyTurbiditySum += allTurbidityData[index];
              weeklyWaterDepthSum += allWaterDepthData[index];
              daysInWeek++;
            }
          });

          if (daysInWeek > 0) {
            filteredTimestamps.push("Week " + (currentDate.getWeek() || 1)); // Display the week number
            filteredTemperatureData.push(weeklyTempSum / daysInWeek);
            filteredTurbidityData.push(weeklyTurbiditySum / daysInWeek);
            filteredWaterDepthData.push(weeklyWaterDepthSum / daysInWeek);
          }
        } else if (timeRange === "monthly") {
          // Calculate monthly averages (for each day of the month)
          let monthlyTempSum = [];
          let monthlyTurbiditySum = [];
          let monthlyWaterDepthSum = [];
          let dayCounts = [];

          allTimestamps.forEach((timestamp, index) => {
            const day = timestamp.getDate();
            if (
              timestamp.getMonth() === currentMonth &&
              timestamp.getFullYear() === currentYear
            ) {
              if (!monthlyTempSum[day]) {
                monthlyTempSum[day] = 0;
                monthlyTurbiditySum[day] = 0;
                monthlyWaterDepthSum[day] = 0;
                dayCounts[day] = 0;
              }
              monthlyTempSum[day] += allTemperatureData[index];
              monthlyTurbiditySum[day] += allTurbidityData[index];
              monthlyWaterDepthSum[day] += allWaterDepthData[index];
              dayCounts[day]++;
            }
          });

          for (let day = 1; day <= 31; day++) {
            if (dayCounts[day]) {
              filteredTimestamps.push(`Day ${day}`);
              filteredTemperatureData.push(
                monthlyTempSum[day] / dayCounts[day]
              );
              filteredTurbidityData.push(
                monthlyTurbiditySum[day] / dayCounts[day]
              );
              filteredWaterDepthData.push(
                monthlyWaterDepthSum[day] / dayCounts[day]
              );
            }
          }
        }

        createMainChart();
        createTemperatureChart();
        createTurbidityChart();
        createWaterDepthChart();
        displayAverages();
      }

      function updateAverageDisplay() {
        // Calculate the average values for each parameter
        const temperatureAvg =
          filteredTemperatureData.reduce((a, b) => a + b, 0) /
            filteredTemperatureData.length || 0;
        const turbidityAvg =
          filteredTurbidityData.reduce((a, b) => a + b, 0) /
            filteredTurbidityData.length || 0;
        const waterDepthAvg =
          filteredWaterDepthData.reduce((a, b) => a + b, 0) /
            filteredWaterDepthData.length || 0;

        // Update the text content of the average display elements
        document.getElementById(
          "temperatureAvg"
        ).textContent = `Average Temperature: ${temperatureAvg.toFixed(2)} 째C`;
        document.getElementById(
          "turbidityAvg"
        ).textContent = `Average Turbidity: ${turbidityAvg.toFixed(2)} NTU`;
        document.getElementById(
          "waterDepthAvg"
        ).textContent = `Average Water Depth: ${waterDepthAvg.toFixed(
          2
        )} meters`;
      }

      function createMainChart() {
        if (mainChartInstance) mainChartInstance.destroy();
        mainChartInstance = new Chart(mainChartContext, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Temperature (째C)",
                data: filteredTemperatureData,
                borderColor: "#FF5733",
                backgroundColor: "rgba(255, 87, 51, 0.2)",
                fill: true,
              },
              {
                label: "Turbidity (NTU)",
                data: filteredTurbidityData,
                borderColor: "#33FF57",
                backgroundColor: "rgba(51, 255, 87, 0.2)",
                fill: true,
              },
              {
                label: "Water Depth (m)",
                data: filteredWaterDepthData,
                borderColor: "#3357FF",
                backgroundColor: "rgba(51, 87, 255, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average values after creating the chart
        updateAverageDisplay();
      }

      function createTemperatureChart() {
        const ctx = document
          .getElementById("temperatureChart")
          .getContext("2d");
        if (temperatureChart) temperatureChart.destroy();
        temperatureChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Temperature (째C)",
                data: filteredTemperatureData,
                borderColor: "#FF5733",
                backgroundColor: "rgba(255, 87, 51, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for temperature
        updateAverageDisplay();
      }

      function createTurbidityChart() {
        const ctx = document.getElementById("turbidityChart").getContext("2d");
        if (turbidityChart) turbidityChart.destroy();
        turbidityChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Turbidity (NTU)",
                data: filteredTurbidityData,
                borderColor: "#33FF57",
                backgroundColor: "rgba(51, 255, 87, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for turbidity
        updateAverageDisplay();
      }

      function createWaterDepthChart() {
        const ctx = document.getElementById("waterDepthChart").getContext("2d");
        if (waterDepthChart) waterDepthChart.destroy();
        waterDepthChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: filteredTimestamps,
            datasets: [
              {
                label: "Water Depth (m)",
                data: filteredWaterDepthData,
                borderColor: "#3357FF",
                backgroundColor: "rgba(51, 87, 255, 0.2)",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
          },
        });

        // Update average value for water depth
        updateAverageDisplay();
      }

      function displayAverages() {
        const avgTemp = calculateAverage(filteredTemperatureData);
        const avgTurbidity = calculateAverage(filteredTurbidityData);
        const avgWaterDepth = calculateAverage(filteredWaterDepthData);

        document.getElementById(
          "temperatureAvg"
        ).textContent = `Avg Temperature: ${avgTemp.toFixed(2)} 째C`;
        document.getElementById(
          "turbidityAvg"
        ).textContent = `Avg Turbidity: ${avgTurbidity.toFixed(2)} NTU`;
        document.getElementById(
          "waterDepthAvg"
        ).textContent = `Avg Water Depth: ${avgWaterDepth.toFixed(2)} m`;
      }

      function calculateAverage(data) {
        const sum = data.reduce((a, b) => a + b, 0);
        return data.length ? sum / data.length : 0;
      }

      document
        .getElementById("timeRange")
        .addEventListener("change", function (event) {
          filterDataByTimeRange(event.target.value);
        });

      fetchData();
    </script>
  </body>
</html>
